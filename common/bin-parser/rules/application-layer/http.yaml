Package:
  operator: |
    res,op = getRootNode("FirstWorld").TryProcess()
    op.Recovery()
    if string(res).HasPrefix("HTTP/") {
      this.GetSubNode("Response").Process()
    }else{
      this.GetSubNode("Request").Process()
    }
  Request:
    FirstLine:
      Method: "del: "
      Path: "del: "
      Version: "del:\r\n"
    Headers: Headers
    Body: Body
  Response:
    FirstLine:
      Version: "del: "
      Status: "del: "
      Message: "del:\r\n"
    Headers: Headers
    Body: Body
FirstWorld: "del: "
Body:
  operator: |
    if getCtx("isChunked") {
      this.GetSubNode("DataChunks").Process()
    }else{
      this.GetSubNode("Data").SetCfg("length", getCtx("body_length"))
      this.GetSubNode("Data").Process()
    }
  Data: raw
  DataChunks:
    isList: true
    DataChunk:
      operator: |
        res = this.GetSubNode("DataChunkLength").Process()
        dump(res)
        length = int(res)
        if length == 0 {
          setCtx("inList",false)
          return
        }
        this.GetSubNode("DataChunk").SetCfg("length", length*8)
        this.GetSubNode("DataChunk").Process()
        this.GetSubNode("DataChunkEnd").Process()
      DataChunkLength: "type:raw;del:\r\n"
      DataChunk: raw
      DataChunkEnd: "del:\r\n"
Headers:
  unpack: true
  operator: |
    for {
      data := this.NewElement().Process()
      if len(data) == 0 {
        this.SetChildren(this.GetChildren()[:-1])
        return
      }
      if string(data).HasPrefix("Content-Length: ") {
        l = int(string(data)[len("Content-Length: "):])
        setCtx("body_length", l*8)
      }
      if string(data).HasPrefix("Transfer-Encoding: chunked") {
        setCtx("isChunked", true)
      }
    }
  isList: true
  Item: "del:\r\n"